title: 分布式接口幂等性设计
keywords: 'RestFulAPI,幂等性'
date: 2016-12-19 14:07:36
categories:
tags: 幂等性
description:
---
<blockquote class="blockquote-center">
    关于分布式系统中接口幂等性设计的介绍
</blockquote>



<!--more-->

## 一、幂等性定义
HTTP/1.1规范中幂等性的定义是：
Methods can also have the property of "idempotence" in that (aside from error or expiration issues) the side-effects of N > 0 identical requests is the same as for a single request.
从定义上看，HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。
更多介绍请阅读[理解HTTP幂等性][1]

## 二、接口中幂等性设计
#### *查询操作*
查询一次和查询多次，在数据不变的情况下，查询结果是一样的，select是天然的幂等操作。

#### *删除操作*
删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)。 

#### *唯一索引，防止新增脏数据*
比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录。

#### *token机制，防止页面重复提交*
业务要求： 
页面的数据只能被点击提交一次 
发生原因： 
由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交
解决办法： 
集群环境：采用token加redis（redis单线程的，处理需要排队） 
单JVM环境：采用token加redis或token加jvm内存 
处理流程： 
1. 数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间 
2. 提交后后台校验token，同时删除token，生成新的token返回 
token特点： 
要申请，一次有效性，可以限流 
注意：redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用 

#### *悲观锁* 
获取数据的时候加锁获取 
select * from table_xxx where id='xxx' for update; 
注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的 
悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用 

#### *乐观锁* 
乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。 

乐观锁的实现方式多种多样可以通过version或者其他状态条件： 

1. 通过版本号实现 
update table_xxx set name=#name#,version=version+1 where version=#version# 

2. 通过条件限制 
update table_xxx set avai_amount=avai_amount-#subAmount# where avai_amount-#subAmount# >= 0 
要求：quality-#subQuality# >= ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高 

注意：乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表，上面两个sql改成下面的两个更好 
update table_xxx set name=#name#,version=version+1 where id=#id# and version=#version# 
update table_xxx set avai_amount=avai_amount-#subAmount# where id=#id# and avai_amount-#subAmount# >= 0 

#### *分布式锁* 
还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。 

要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供) 

#### *select + insert* 
并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了 
注意：核心高并发流程不要用这种方法 

#### *状态机幂等* 
在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。 

注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助 

#### *对外提供接口的api如何保证幂等* 
如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号 
source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求) 

**重点：** 
对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。 



> 参考阅读
- [高并发的核心技术-幂等性实现方案](http://825635381.iteye.com/blog/2276077)


  [1]: http://www.cnblogs.com/weidagang2046/archive/2011/06/04/idempotence.html